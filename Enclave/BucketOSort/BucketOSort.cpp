#include "BucketOSort.hpp"


unsigned char* initializeOutbuf(bos_params *params){
  // Accounting for additional packets that arise from flushBuffers
  // NOTE: evict_start should be such that B*f/evict_start % f == 0!
  // fb_apb = additional packets per buffer due to flush buffer
  size_t fb_apb = (params->d * (params->B*params->f - params->evict_start) / params->f);
  size_t num_packets_in_outbuf_bucket = params->Z + fb_apb;
  size_t apb = 0;
  size_t block_size = params->block_size;
  FOAV_SAFE2_CNTXT(initializeOutbuf, params->n, params->n_1)
  if(params->n > params->n_1) {
    //printf("N = %d, N_1 = %d\n", params->n, params->n_1);
    apb = (2*(params->n - params->n_1) + (params->b - 1))/params->b;
  }
  num_packets_in_outbuf_bucket+=apb;

  //printf("d = %d, b = %d, B = %d, f = %d\n", params->d, params->b, params->B, params->f);
  //printf("Allocating outbuf, num_packets_in_outbuf_bucket = %d\n", num_packets_in_outbuf_bucket);
  size_t outbuf_size = (block_size) * (params->b * num_packets_in_outbuf_bucket);

  unsigned char *outbuf = (unsigned char *) malloc (outbuf_size);
  if(outbuf==NULL){
    printf("malloc for outbuf in initializeOutbuf failed\n");
  }

  unsigned char *outbuf_ptr = outbuf;
  // Initialize outbuf with all dummy packets
  // Since we allocate ~the exact number of slots we need per bucket 
  // (max 1 extra unused packet per bucket), we can either just initialize the last 
  // packet of each bucket, or forego this initialization altogether.
  for(uint64_t i=0; i<params->b*num_packets_in_outbuf_bucket; i++){
    setDummy(outbuf_ptr);
    outbuf_ptr += block_size;
  }
  
  params->num_packets_in_outbuf_bucket = num_packets_in_outbuf_bucket;
  params->ORP_packet_size = block_size + 16;
  return outbuf;
}


double BOS(unsigned char *input, size_t N, size_t block_size, bos_params* params, 
          unsigned char* &expanded_buffer, size_t nthreads, unsigned char* output, enc_ret *ret) {
  double ptime;

  //Allocate the needed outbuf here and let output point to it.
  expanded_buffer = initializeOutbuf(params);

  FOAV_SAFE_CNTXT(BOS, block_size)
  if(block_size==8) {
    BucketOSort<OSWAP_8> *bos_node = new BucketOSort<OSWAP_8>(params, expanded_buffer, nthreads);
    ptime = bos_node->sort(input, N, block_size, output, ret);
    delete bos_node;
  } else if(block_size%16==0){
    BucketOSort<OSWAP_16X> *bos_node = new BucketOSort<OSWAP_16X>(params, expanded_buffer, nthreads); 
    ptime = bos_node->sort(input, N, block_size, output, ret);
    delete bos_node;
  } else{
    BucketOSort<OSWAP_8_16X> *bos_node = new BucketOSort<OSWAP_8_16X>(params, expanded_buffer, nthreads); 
    ptime = bos_node->sort(input, N, block_size, output, ret);
    delete bos_node;
  }
  return ptime;
}

double BORP(unsigned char *input, size_t N, size_t block_size, bos_params* params,
            unsigned char* &expanded_buffer, size_t nthreads, unsigned char *result_buf, enc_ret *ret) {
  double ptime;

  //Allocate the needed outbuf here and let output point to it.
  expanded_buffer = initializeOutbuf(params);
  
  // Here we only opt between OSWAP_16X or OSWAP_8_16X, since all of BORP's OSWAPs happen on ORP_packets whic
  // have size = block_size + 16 (from the attached random label, and eviction stream for it)
  FOAV_SAFE_CNTXT(BORP, block_size)
  if(block_size%16==0){
    BucketOSort<OSWAP_16X> *bos_node = new BucketOSort<OSWAP_16X>(params, expanded_buffer, nthreads); 
    ptime = bos_node->ORP(input, N, block_size, result_buf, ret); 
    delete bos_node;
  } else{
    BucketOSort<OSWAP_8_16X> *bos_node = new BucketOSort<OSWAP_8_16X>(params, expanded_buffer, nthreads); 
    ptime = bos_node->ORP(input, N, block_size, result_buf, ret); 
    delete bos_node;
  }
  return ptime;
}

double DecryptAndBOS(unsigned char *encrypted_buffer, size_t N, size_t encrypted_block_size, 
        bos_params *params, size_t nthreads, unsigned char *result_buffer, enc_ret *ret){
  double ptime, qtime;
  long t1, t2;

  // Decrypt buffer to decrypted_buffer
  unsigned char *decrypted_buffer = NULL;
  // The BORP call will populate the expanded buffer which stores all the packets after the BRN
  // i.e. it 2N + more packets than the original N packets, from the dummies injected at the start
  // + more from the dummies generated by the flushBuffer operation.
  unsigned char *expanded_buffer = NULL;

  size_t decrypted_block_size = decryptBuffer(encrypted_buffer, N, encrypted_block_size, &decrypted_buffer);


  unsigned char* outbuf_iter = decrypted_buffer;

  // BORP takes the decrypted_buffer, runs all the N packets in it through BRN, and ends up with the 2N + more packets
  // in the expanded_buffer, after this point, we use decrypted_buffer as the location for Phase 2 to drop all the real
  // packets post compaction and shuffling.
  PRB_pool_init(nthreads);
  ptime = BORP(decrypted_buffer, N, decrypted_block_size, params, expanded_buffer, nthreads, decrypted_buffer, ret);

  ocall_clock(&t1);
  qsort(decrypted_buffer, N, decrypted_block_size, compare);
  ocall_clock(&t2);
  ret->qsort_time = ((double)(t2-t1))/1000.0;

  // Encrypt the results (decrypted_buffer) to result_buffer
  encryptBuffer(decrypted_buffer, N, decrypted_block_size, result_buffer);

  FOAV_SAFE2_CNTXT(DecryptAndBORP, decrypted_buffer, encrypted_buffer)
  free(decrypted_buffer);
  free(expanded_buffer);
  PRB_pool_shutdown();

  ret->OSWAP_count = OSWAP_COUNTER;
  ret->ptime = ptime; 
  return (ptime);
}

double DecryptAndBORP(unsigned char *encrypted_buffer, size_t N, size_t encrypted_block_size, 
        bos_params *params, size_t nthreads, unsigned char *result_buffer, enc_ret *ret){

  double ptime;

  // Decrypt buffer to decrypted_buffer
  unsigned char *decrypted_buffer = NULL;
  // The BORP call will populate the expanded buffer which stores all the packets after the BRN
  // i.e. it 2N + more packets than the original N packets, from the dummies injected at the start
  // + more from the dummies generated by the flushBuffer operation.
  unsigned char *expanded_buffer = NULL;

  size_t decrypted_block_size = decryptBuffer(encrypted_buffer, N, encrypted_block_size, &decrypted_buffer);


  unsigned char* outbuf_iter = decrypted_buffer;

  // BORP takes the decrypted_buffer, runs all the N packets in it through BRN, and ends up with the 2N + more packets
  // in the expanded_buffer, after this point, we use decrypted_buffer as the location for Phase 2 to drop all the real
  // packets post compaction and shuffling.
  PRB_pool_init(nthreads);
  ptime = BORP(decrypted_buffer, N, decrypted_block_size, params, expanded_buffer, nthreads, decrypted_buffer, ret);

  // Encrypt the results (decrypted_buffer) to result_buffer
  encryptBuffer(decrypted_buffer, N, decrypted_block_size, result_buffer);

  FOAV_SAFE2_CNTXT(DecryptAndBORP, decrypted_buffer, encrypted_buffer)
  free(decrypted_buffer);
  free(expanded_buffer);
  PRB_pool_shutdown();

  ret->OSWAP_count = OSWAP_COUNTER;
  ret->ptime = ptime; 
  return (ptime);
}
