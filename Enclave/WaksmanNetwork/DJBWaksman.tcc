/*
  Takes the control bits generated by generateControlBits(), a buffer of data to permute,
  and the block size of data elements in the buffer.
  It returns buffer, with the elements permuted in place by the permutation used to 
  create the controlbits.
  
  - control_bits  : the bit array returned by generateControlBits
  - C             : len of control_bits array
  - buffer        : the data buffer to permute
  - block_size    : block size of data elements in buffer 
*/

template <OSwap_Style oswap_style>
void applyPermutation(bool *control_bits, size_t C, unsigned char *buffer, size_t N,
        size_t block_size){
  int m = log2(N);

  for(int i=0; i<2*m-1; i++) {
    size_t gap = 1 << min(i, 2*m-2-i);
    //printf("AP: Layer = %d, gap = %d\n", i, gap);
    for(size_t j=0; j<N/2; j++) {
      size_t pos = (j%gap) + 2*gap*(j/gap);
      bool swap_flag = control_bits[i*(N/2)+j];
      //printf("Swap (%d, %d) ? %d\n", pos, pos + gap, swap_flag);
      oswap_buffer<oswap_style>(buffer+(pos*block_size), 
                      buffer+(pos+gap)*block_size, block_size, swap_flag);
    } 
  }
}


/*
  Takes the control bits generated by generateControlBits(), a buffer of data to permute,
  and the block size of data elements in the buffer.
  It returns buffer, with the elements permuted in place by the permutation used to 
  create the controlbits.
  
  - control_bits_f : control bits for front layer of recursion
  - control_bits_b : control bits for back layer of recursion
  - buffer         : the data buffer to permute
  - N              : the number of items
  - gN             : the global N (needed to traverse the control_bits_x arrays correctly)
  - block_size     : block size of data elements in buffer
  - offset         : the parity for this level of recursion
*/

template <OSwap_Style oswap_style>
void applyPermutation(bool *control_bits_f, bool *control_bits_b, 
      unsigned char *buffer, size_t N, size_t gN, size_t block_size, size_t offset){

  // Base case, N=2. DJB Controlbit algorithm is only for powers of 2.
  if(N==2) {
    size_t gap = gN/N;
    bool swap_flag = control_bits_f[offset];
    oswap_buffer<oswap_style>(buffer+offset*block_size, 
                      buffer+(offset+gap)*block_size, block_size, swap_flag);
  } 
  else{
    size_t gap = gN/N;
    for(size_t j=0; j<N/2; j++) {
      bool swap_flag = control_bits_f[j*gap+offset];
      size_t pos = 2*gap*j+offset;
      oswap_buffer<oswap_style>(buffer+((pos)*block_size), 
                    buffer+(pos+gap)*block_size, block_size, swap_flag);
    }

    // Then recurse into even and odd switches.
    applyPermutation<oswap_style>(control_bits_f+gN/2, control_bits_b-gN/2, buffer, N/2, gN, block_size, offset);
    applyPermutation<oswap_style>(control_bits_f+gN/2, control_bits_b-gN/2, buffer, N/2, gN, block_size, offset+gap);        
    for(size_t j=0; j<N/2; j++) {
      bool swap_flag = control_bits_b[j*gap+offset];
      size_t pos = 2*gap*j+offset;
      oswap_buffer<oswap_style>(buffer+((pos)*block_size), 
                    buffer+(pos+gap)*block_size, block_size, swap_flag);
    }
  }
}
