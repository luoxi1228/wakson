We tested our artifact on Ubuntu 20.04 and 22.04. Our results can be reproduced
on a machine with either of these OS with the instructions below.

To start, make sure that SGX is set up correctly.
[README.sgx.md](README.sgx.md) provides instructions to do so.

Our plotter scripts and the meta script to run experiments uses python3.
So first make ensure that python3 and the following python3 packages are 
installed on the machine:

  - numpy
  - matplotlib

------------------------------------------------------------------------

# (I) Running Experiments

To run our experiments and gather the data to plot:

  1. In artifact_folder/, run

        make clean
	    make

  2. In the Application folder, the `run_experiments.py` script is meant to
       run all the shuffling and sorting algorithms over a wide range of number
       of items N, and BLOCK_SIZES. You can reconfigure the experiments and
       modes in the "CONFIGS to SET" section of the script, to run select
       experiments. The starting state of this CONFIG corresponds to the
       experiments we ran and can reproduce the graphs in our paper. The
       important config is the RESULTS_FOLDER, which will store all the data
       generated from the experiments, and will be used later to plot the data.

       (NOTE: It took us about 2 days of compute to run all the experiments
       and gather the data to plot. Alternatively, we also provide the data from
       our experiments in the artifact_folder/plots/Our_Data, and this can be
       reused to recreate our graphs.)

        ./run_experiments.py

    Note the above steps reproduce all the MODES presented in our paper, except
    BORPStream V1. To reproduce BORPStream V1 results:

    - Set the run_experiments.py CONFIGs to just MODES = [3, 13], and set the 
      OPT_TARGET flag to 1 (V1 mode). Make sure the RESULTS_FOLDER points to 
      some other temporary folder other than the one holding all the other data
      files. 
    - Run the experiments with `./run_experiments.py`. 
    - In the temporary RESULTS_FOLDER, rename all mode 3_XXXX.lg files to 
      33_XXXX.lg, and similarly all 13_XXXX.lg files to 43_XXXX.lg 
      Copy these files over to the main RESULTS_FOLDER, and use this folder as
      the command line arguments for `./plot_paper_graphs.py`

    BORPStream V1's performance is strictly lower than BORPStream V2 anyway
    as our results show. So one can skip the above process altogether and
    just generate results and plots without BORPStream V1.


# (II) Plotting the data

Once RESULTS_FOLDER is populated with the data. Switch over to to the 
    plots/ folder in artifact_folder, and run:

    ./plot_paper_graphs <RESULTS_FOLDER_LOCATION>

Or to simply reuse our data

    ./plot_paper_graphs Our_Data

All the graphs will be generated in the same folder as the data.


# (III) Parsing / Reading the log files generated

All of the data log files generated by running experiments produce a .csv 
    format file with the file name <MODE>_<BLOCKSIZE>.lg
    Since the different modes have different phases, each mode has its own 
    column breakdown, and we list them below.
    
MODE List:

	Shuffles:
	    1 = RecursiveShuffle_M1 (with Goodrich's OP_TightCompact)
	    2 = ORShuffle
	    3 = BORPStream (Bucket Oblivious Random Permutation Stream)
	    5 = BitonicSort Shuffle
	    7 = WaksShuffle
	    8 = Bucket Oblivious Random Permutation (with TC)
	    9 = Nassimi-Sahni Waksman Shuffle

	Sorts:
	    10 = Nassimi-Sahni Waksman Sort
	    12 = Oblivious Sort (Sorting Network - BitonicSort)
	    13 = Oblivious Sort (BORPStream + Quicksort, lambda = -80)
	    14 = Oblivious Sort (ORShuffle + Quicksort)
	    15 = WaksShuffle (Mode 7) + Quicksort
	    17 = WaksSort



    Shorthand titles for the recurring column values:
    ITT = Ignored Total Time. The total time inclusive of the cost to generate
          data to sort/shuffle, and encrypt it for the enclave.
    TT = Actual Total Time taken to run the MODE in the enclave once all its
         inputs are provided.


    For Modes 2 (ORShuffle), 5 (Bitonic Shuffle), and 12 (Bitonic Sort):
        The values correspond to:
        N, ITT, ITT_stddev, TT, TT_stddev, NULL, NULL, OSWAP_COUNT


    For Modes 3 (BORPStream V2), 33 (BORPStream V1), 13 (BORPStream V2 + 
    QuickSort), and 43 (BORPStream V1 + Quicksort)
        N, ITT, ITT_stddev, TT, TT_stddev, P2T, P2T_stddev, OSWAP_PPTBRN, 
        OSWAP_FB, OSWAP_P2

	Here:
        - P2T : Phase 2 Time
        - OSWAP_PPTBRN: OSWAP Count of Process Packets Through BRN (Phase1)
        - OSWAP_FB: OSWAP Count for FlushBuffers (Phase1)
        - OSWAP_P2: OSWAP Count for Phase2

        Mode 13 (BORPStream V2 + QuickSort) and 43 (BORPStream V1 + Quicksort)
        use have the same column structure as above, with two additional 
        columns at the end:
        QST, QST_stddev

        Here:
        - QST: QuickSort Time


    For Mode 14 (ORShuffle + QuickSort):
        The values correspond to:
        N, ITT, ITT_stddev, TT, TT_stddev, NULL, NULL, OSWAP_COUNT, QST, 
        QST_stddev

        Here:
        - QST: QuickSort Time


    For Modes 7 (WaksShuffle), 9 (Nassimi-Sahni Waksman Shuffle), 
    10 (Nassimi-Sahni Waksman Sort), 15 (WaksShuffle + QS), and 17 (WaksSort):

        N, ITT, ITT_stddev, TT, TT_stddev, GPT, GPT_stddev, OSWAP_AP, CBT, 
        CBT_stddev, APT, APT_stddev, OSWAP_GP, OSWAP_CB, OSWAP_AP

	Here:
        - GPT: Generate Permutation Time (Permutation to shuffle data to)
        - CBT: Control Bit setting Time
        - APT: Apply Permutation Time
        - OSWAP_GP: OSWAP count for Generate Permutation
        - OSWAP_CB: OSWAP count for Control Bit generation
        - OSWAP_AP: OSWAP count for Apply Permutation

        Mode 15 (WaksShuffle + QS) has the same column structure as above,
        with the two additional columns for QuickSort at the end:
        QST, QST_stddev


